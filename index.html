<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<script type="text/javascript" src="jquery-1.9.0.min.js"></script>

<style>

    :root {
        /*--main-color: #7597ce;*/
        --main-color: #0699fa;
    }
    
    #bound {
        width: 1024px;
        height: auto;
        margin: 0px auto;
        text-align: left;
        background-color:#fff;
        
        padding:30px;
        margin-top:0px;
    }

    body {
        background-color:#eee;
        font-family:"Ubuntu Light";
        font-size: 18px;
        padding:0px;
        margin:0px;
    }
    
    h1 { 
        color: var(--main-color);
    }
    
    h3 { 
        color: var(--main-color);
        margin:0px;
    }
    
    a {
        text-decoration: none;
        color: var(--main-color);
    }

    a:hover {
        text-decoration: none;
        color: var(--main-color);
    }
    
    hr {
        background: var(--main-color);
        border: 0; height: 1px;
    }
        
    .table {
    }
    
    td {
        padding-right:20px;
        font-family:"Ubuntu Light";
        font-size: 16px;
    }

    input[type="text"] {
        padding:3px;
        font-family:"Ubuntu Light";
        font-size: 16px;
        color: var(--main-color);
        width:80px;

    }
    
    button {
        padding:10px;
        font-family:"Ubuntu Light";
        font-size: 16px;
        width:100px;
    }

    span {
        color: var(--main-color);
    }
    
    #header-bound {
        background-color:#dedede;
        color:#333;
        font-size:12px;
        width: 1074px;
        height: auto;
        margin: 0px auto;
        text-align: left;
        margin-top:0px;
        padding:5px;
    }
}
</style>

<body>

<div id="header-bound">
This model is open source, view the source code and learn how it works on github: <a href="https://github.com/philJam/energymodel">https://github.com/philJam/energymodel</a>.
Comment on the model and see what further development is planned <a href="http://zcb.wikispot.org/OpensourceEnergyModel">here</a>.
You can also download the full ten year hourly model used for ZCB <a href="https://dl.dropboxusercontent.com/u/79311585/ZCB_TYHME_v2.xlsx">here</a>.
</div>

<div id="bound">

<h1>ZERO CARBON ENERGY MODEL</h1>
<p>Hourly zero carbon energy model for the UK.</p>

<div style="overflow: scroll; overflow-y: hidden;">
<canvas id="graph" width="8760" height=250"></canvas>

</div>
<br>
<button id="balance">Balance</button>
<button id="supply">Supply</button>
<button id="demand">Demand</button>
<button id="store">Store</button>

<hr><h3>INPUT</h3><hr>
<table style="width:100%">

    <tr>
        <th style="text-align:left">Supply</th><th></th>
    </tr>
    <tr><td>GW</td></tr>
    <tr>
        <td>Onshore wind</td><td><input type="text" key="input.onWindCap"></td>        
        <td>Solar</td><td><input type="text" key="input.solarCap"></td>
        <td>Wave</td><td><input type="text" key="input.waveCap"></td>
        <td>Nuclear</td><td><input type="text" key="input.nuclearCap"></td>       
    </tr>
    <tr>
        <td>Offshore wind</td><td><input type="text" key="input.offWindCap"></td>
        <td>Hydro</td><td><input type="text" key="input.hydroCap"></td>
        <td>Tidal</td><td><input type="text" key="input.tidalCap"></td>
    </tr>
    <tr><td>Backup capacity</td><td><input type="text" key="input.backupCap"></td></tr>
    <tr><td><BR></td></tr>
    <tr><td>Biomass</td><td><input type="text" key="input.biomassSupply"></td><td>TWh/yr</td></tr>
    <tr><td><BR></td></tr>
    
    <tr>
        <th style="text-align:left">Demand</th><th></th>
    </tr>
    <tr>    
        <td>Heat loss of buildings</td><td><input type="text" key="input.heatLossCoefficient"></td><td>GW/Â°C</td>
    </tr>
    <tr>
        <td>Hot water (heat)</td><td><input type="text" key="input.hotWaterDemand_TWh"></td><td>TWh/yr</td>
    </tr>
    <tr>
        <td></td><td>Direct electric</td><td>Heat pumps</td><td>Solid</td><td>Gas</td><td>Liquid</td><td>CHP(s)</td><td>CHP(g)</td><td>CHP(l)</td>
        <tr>    
        <td>% heat demand met by...</td><td><input type="text" key="input.percentHeatDirectelec"></td><td><input type="text" key="input.percentHeatHeatpumps"></td>
        <td><input type="text" key="input.percentHeatSolid"></td><td><input type="text" key="input.percentHeatGas"></td>
        <td><input type="text" key="input.percentHeatLiquid"></td><td><input type="text" key="input.percentHeatCHPSolid"></td>
        <td><input type="text" key="input.percentHeatCHPGas"></td><td><input type="text" key="input.percentHeatCHPLiquid"></td>
        </tr>
    </tr>
    <tr><td><BR></td></tr>
    
    <tr><td>TWh/yr</td><td>Electricity</td><td>Solid</td><td>Gas</td><td>Liquid</td><td>CHP(s)</td><td>CHP(g)</td><td>CHP(l)</td><td>Hydrogen</td></tr>
    <tr>
        <td>Appliances, lighting & cooking</td><td><input type="text" key="input.appliancesDemand_TWh"></td>
        <td><input type="text" key="input.appliancesSolidDemand"></td><td><input type="text" key="input.appliancesGasDemand"></td>
        <td><input type="text" key="input.appliancesLiquidDemand"></td>
    </tr>
    <tr>
        <td>Transport</td><td><input type="text" key="input.transportDemand_TWh"></td>
        <td><input type="text" key="input.transportSolidDemand"></td><td><input type="text" key="input.transportGasDemand"></td>
        <td><input type="text" key="input.transportLiquidDemand"></td><td></td><td></td><td></td>
        <td><input type="text" key="input.transportHydrogenDemand"></td><td>
    </tr>
    <tr>
        <td>Industry</td><td><input type="text" key="input.industryDemand_TWh"></td>
        <td><input type="text" key="input.industrySolidDemand"></td><td><input type="text" key="input.industryGasDemand"></td>
        <td><input type="text" key="input.industryLiquidDemand"></td><td><input type="text" key="input.industryCHPSolidDemand"></td>
        <td><input type="text" key="input.industryCHPGasDemand"></td><td><input type="text" key="input.industryCHPLiquidDemand"></td>
        <td><input type="text" key="input.industryHydrogenDemand"></td><td>
    </tr>
    <tr><td COLSPAN=2><BR></td></tr>
    
    <tr>
        <th style="text-align:left">Storage</th><th></th>
    </tr>
    <tr>
        <td>Electricity store</td>
    </tr>
    <tr>
        <td COLSPAN=2>Store max discharge rate (GW)</td><td><input type="text" key="input.store_max_discharge_rate"></td>    
        <td COLSPAN=2>Store max charge rate (GW)</td><td><input type="text" key="input.store_max_charge_rate"></td>
        <td COLSPAN=2>Store max capacity (GWh)</td><td><input type="text" key="input.store_max_capacity_GWh"></td>
    </tr>
    <tr>
        <td COLSPAN=2>Store discharge efficiency</td><td><input type="text" key="input.store_discharge_efficiency"></td>
        <td COLSPAN=2>Store charge efficiency</td><td><input type="text" key="input.store_charge_efficiency"></td>
        <td COLSPAN=2>Store start capacity (GWh)</td><td><input type="text" key="input.store_start_capacity_GWh"></td>
    </tr>
    <tr><td><BR></td></tr>
    <tr>
        <td>Hydrogen</td>
    </tr>
    <tr>
        <td COLSPAN=2>Electrolysis capacity</td><td><input type="text" key="input.electrolysisCap"></td><td>GW</td>
        <td COLSPAN=3>Use hydrogen for synthetic fuels</td>
        <td><select type = "text" key="input.useH2ForSynthFuels">
            <option value="0" selected>Yes</option>
            <option value="1">No</option>
            </select>
        </td>
    </tr>
    <tr><td><BR></td></tr>
    
</table>

<button id="run">Run</button>
<br>
<hr><h3>OUTPUT</h3><hr>
<table style="width:100%">


    <tr>
        <th style="text-align:left">Supply</th><th></th>
        <th style="text-align:left">Demand</th><th></th>
        <th style="text-align:left">Store</th><th></th>
    </tr>

    <tr>
        <td>Offshore wind</td><td><span key="out.offWindGeneration" scale=0.001 dp=1></span> TWh/yr</td>
        <td>Total heat demand</td><td><span key="out.totalHeatDemand" scale=0.001 dp=1></span> TWh/yr</td>
        <td>Max discharge rate</td><td><span key="out.store_used_discharge_rate" dp=1></span> GW</td>
    </tr>

    <tr>
        <td>Onshore wind</td><td><span key="out.onWindGeneration" scale=0.001 dp=1></span> TWh/yr</td>
        <td></td><td></td>
        <td>Max charge rate</td><td><span key="out.store_used_charge_rate" dp=1></span> GW</td>
    </tr>
    
    <tr>
        <td>Solar</td><td><span key="out.solarGeneration" scale=0.001 dp=1></span> TWh/yr</td>
        <td>Total electricity demand</td><td><span key="out.demandGWh" scale=0.001 dp=1></span> TWh/yr</td>
        <td>Lowest capacity</td><td><span key="out.store_used_min_capacity" dp=1></span> GWh</td>
    </tr>
    
    <tr>
        <td>Hydro</td><td><span key="out.hydroGeneration" scale=0.001 dp=1></span> TWh/yr</td>
        <td></td><td></td>
        <td>Highest capacity</td><td><span key="out.store_used_max_capacity" dp=1></span> GWh</td>
    </tr>
    
    <tr>
        <td>Wave</td><td><span key="out.waveGeneration" scale=0.001 dp=1></span> TWh/yr</td>
        <td>Unmet electricity demand</td><td><span key="out.unmetDemand" scale=0.001 dp=1></span> TWh/yr</td>    
        <td>Total charge</td><td><span key="out.store_total_charge" scale=0.001 dp=1></span> TWh</td>
    </tr>
    
    <tr>
        <td>Tidal</td><td><span key="out.tidalGeneration" scale=0.001 dp=1></span> TWh/yr</td>
        <td>Max shortfall</td><td><span key="out.max_shortfall" dp=1></span> GW</td>
        <td>Total discharge</td><td><span key="out.store_total_discharge" scale=0.001 dp=1></span> TWh</td>
    </tr>
    
    <tr>
        <td>Nuclear</td><td><span key="out.nuclearGeneration" scale=0.001 dp=1></span> TWh/yr</td>
        <td></td><td></td>
        <td>Total loss</td><td><span key="out.store_total_loss" scale=0.001 dp=1></span> TWh</td>
    </tr>
    
    <tr>
        <td>Excess generation</td><td><span key="out.excessGeneration" scale=0.001 dp=1></span> TWh/yr</td>
        <td></td><td></td>
        <td>End capacity level</td><td><span key="out.store_capacity" dp=1></span> GWh</td>        
    </tr>
    
    <tr>
        <td>Backup generation</td><td><span key="out.backupGeneration" scale=0.001 dp=1></span> TWh/yr</td>
        <td></td><td></td>
        <td></td><td></td>        
    </tr>
    
    <tr>
        <td>Backup capacity used</td><td><span key="out.backupCapUsed" dp=1></span> GW</td>
        <td></td><td></td>
        <td></td><td></td>        
    </tr>
    
    <tr><td><BR></td></tr>
    
    <tr>
        <td>Solid biomass fuel</td><td><span key="out.solidBiofuel" scale=0.001 dp=1></span> TWh/yr</td>
        <td>Solid fuel</td><td><span key="out.solidDemand" scale=0.001 dp=1></span> TWh/yr</td>
        <td>Hydrogen produced</td><td><span key="out.hydrogenProduced" scale=0.001 dp=1></span> TWh/yr</td>
    <tr>
        <td>Biogas/synthetic gas</td><td><span key="out.gasBiofuel" scale=0.001 dp=1></span> TWh/yr</td>
        <td>Gas fuel</td><td><span key="out.gasDemand" scale=0.001 dp=1></span> TWh/yr</td>
        <td>Hydrogen surplus</td><td><span key="out.hydrogen_surplus" scale=0.001 dp=1></span> TWh/yr</td>
    </tr>
    <tr>
        <td>Biofuel/synthetic liquid</td><td><span key="out.liquidBiofuel" scale=0.001 dp=1></span> TWh/yr</td>
        <td>Liquid fuel</td><td><span key="out.liquidDemand" scale=0.001 dp=1></span> TWh/yr</td>
        <td>Biomass surplus</td><td><span key="out.biomass_surplus" scale=0.001 dp=1></span> TWh/yr</td>
    </tr>
    <tr>
        <td>Unmet solid demand</td><td><span key="out.unmet_solid_demand" scale=0.001 dp=1></span> TWh/yr</td>        
        <td></td><td></td>  
        <td></td><td></td>
    </tr>
    <tr>
        <td>Unmet gas demand</td><td><span key="out.unmet_gas_demand" scale=0.001 dp=1></span> TWh/yr</td>
        <td></td><td></td>
        <td></td><td></td>        
    </tr>
    <tr>
        <td>Unmet liquid demand</td><td><span key="out.unmet_liquid_demand" scale=0.001 dp=1></span> TWh/yr</td>
        <td></td><td></td>
        <td></td><td></td>        
    </tr>
    <tr>
        <td>Unmet hydrogen demand</td><td><span key="out.unmet_hydrogen" dp=1></span> TWh/yr</td>
        <td></td><td></td>
        <td></td><td></td>        
    </tr>
    <tr>
        <td><h3>Residual Emissions</td><td><span key="out.residual_emissions" scale=0.001 dp=1></span> MtCO2/yr</h3></td>
        <td></td><td></td>
        <td></td><td></td>        
    </tr>
    <tr><td><BR></td></tr>
    
</table>



</div>

<div id="header-bound">
This model is open source, view the source code and learn how it works on github: <a href="https://github.com/philJam/energymodel">https://github.com/philJam/energymodel</a>.
Comment on the model and see what further development is planned <a href="http://zcb.wikispot.org/OpensourceEnergyModel">here</a>.
You can also download the full ten year hourly model used for ZCB <a href="https://dl.dropboxusercontent.com/u/79311585/ZCB_TYHME_v2.xlsx">here</a>.
</div>

</body>

<script>

    var csvfile = "";
    var excessGeneration = 0;
    var unmetDemand = 0;
    
    var energyDemand = [];
    var onWindPower = [];
    var offWindPower = [];
    var solarPower = [];
    var wavePower = [];
    var tidalPower = [];
    var hourlyHeatDemand = [];
    var hourlyElecForHeatDemand = [];
    var hourlySpaceHeatDemand = [];
    var hourlyWaterHeatDemand = [];
    var hourlyElecForIndustry = [];
    var temperatureData = [];
    var totalGeneration = [];
    var unmet = [];
    var backupUsed = [];
    
    var onWindCap = 20; // GW
    var offWindCap = 140; // GW
    var solarCap = 70; // GW
    var hydroCap = 3; // GW
    var waveCap = 10; // GW
    var tidalCap = 20; // GW
    var nuclearCap = 0; // GW
    var backupCap = 45; // GW
    var biomassSupply = 274; // TWh/yr
    
    var demandProfile = 0;
    var heatLossCoefficient = 4.4; // GW/degC
    var baseTemp = 16-(385/((heatLossCoefficient/4.398)*119)); //Gains need linking to appliances energy reduction
    var totalHeatDemand = 0;
    var totalDemandInProfile = 0;
    var heatPumpCoP = 2.5;
    var hotWaterDemand_TWh = 96;
    var percentHeatDirectelec = 10;
    var percentHeatHeatpumps = 85;
    var percentHeatSolid = 5;
    var percentHeatGas = 0;
    var percentHeatLiquid = 0;
    var percentHeatCHPSolid = 0;
    var percentHeatCHPGas = 0;
    var percentHeatCHPLiquid = 0;
    var appliancesDemand_TWh = 105;
    var appliancesSolidDemand = 0;
    var appliancesGasDemand = 0;
    var appliancesLiquidDemand = 0;
    var transportDemand_TWh = 42;
    var transportSolidDemand = 0;
    var transportGasDemand = 0;
    var transportLiquidDemand = 98;
    var transportHydrogenDemand = 13;
    var industryDemand_TWh = 171;
    var industrySolidDemand = 0;
    var industryGasDemand = 61;
    var industryLiquidDemand = 12;
    var industryCHPSolidDemand = 26;
    var industryCHPGasDemand = 0;
    var industryCHPLiquidDemand = 0;
    var industryHydrogenDemand = 0;
    var useH2ForSynthFuels = 0;
    var unmet_hydrogen = 0;
    
    var solidDemand = 0;
    var gasDemand = 0;
    var liquidDemand = 0;
    var solidBiofuel = 0;
    var gasBiofuel = 0;
    var liquidBiofuel = 0;
    var biomassForSolid = 0;
    var biomassForGas = 0;
    var biomassForSynthLiquid = 0;
    var biomassForSynthGas = 0;
    var biomassForLiquid = 0;
    
    var onWindGeneration = 0;
    var offWindGeneration = 0;
    var solarGeneration = 0;
    var hydroGeneration = 0;
    var waveGeneration = 0;
    var tidalGeneration = 0;
    var nuclearGeneration = 0;
    var backupGeneration = 0;
    var backupCapUsed = 0;
    var demandGWh = 0;
    var totalGenerationTWh = 0;
    var max_shortfall = 0;
    var total_store_loss = 0;
    
    var grid_loss = 0.07; // 7% - apply to supply from renewables (except PV & CHP), nuke & backup.
    
    //------------------------------------------------
    // Storage capacity, size, performance
    var store_max_discharge_rate   = 10;      // GW
    var store_max_charge_rate      = 10;      // GW
    var store_max_capacity_GWh     = 500;    // TWh
    var store_max_capacity         = store_max_capacity_GWh;
    var store_discharge_efficiency = 0.9;     // 90%
    var store_charge_efficiency    = 0.9;     // 90%
    
    var electrolysisCap = 35; // GW
    var electrolysisDemand = [];
    var hydrogenProduced = 0;
    
    // Variables to record utilisation of store
    var store_used_discharge_rate = 0;
    var store_used_charge_rate = 0;
    var store_used_min_capacity = store_max_capacity;
    var store_used_max_capacity = 0;
    var store_total_charge = 0;
    var store_total_discharge = 0;
    var store_total_loss = 0;
    
    var store_start_capacity_GWh   = store_max_capacity_GWh /2;    // GWh
    var store_start_capacity       = store_start_capacity_GWh;
    var store_capacity = store_start_capacity;
    //------------------------------------------------
    var store_hourly_capacity = [];
    var storageChange = [];
    
    $("[key]").each(function(){
        var keyparts = $(this).attr('key').split(".");
        if (keyparts[0]=='input') $(this).val(window[keyparts[1]]);
    });
    
    
    var spaceHeatingDailyProfile = [0.8,0.8,0.9,0.9,1.7,6.5,7.7,8.3,7.5,6.0,4.6,4.0,3.5,3.3,3.3,3.4,3.7,4.1,5.2,6.3,6.4,6.1,4.2,0.8];
    var hotWaterDailyProfile = [4.1,4.1,4.1,4.1,4.1,4.1,4.1,4.1,4.2,4.2,4.2,4.2,4.2,4.2,4.2,4.2,4.2,4.2,4.2,4.2,4.2,4.2,4.2,4.2];
    // [0.1,0.1,0.1,0.5,1.5,3.5,7.6,10.2,11.2,6.9,4.6,3.0,1.9,1.9,2.1,3.0,7.0,7.8,7.1,5.8,4.5,3.7,3.2,2.7];
    var industrialDailyProfile = [4.1,4.1,4.1,4.1,4.1,4.1,4.1,4.1,4.2,4.2,4.2,4.2,4.2,4.2,4.2,4.2,4.2,4.2,4.2,4.2,4.2,4.2,4.2,4.2];
    // [1,1,1,1,1,1,1,1,10.5,10.5,10.5,10.5,10.5,10.5,10.5,10.5,1,1,1,1,1,1,1,1];


    var graph_mode = 'balance';
    
    
    function process()
    {
        excessGeneration = 0;
        onWindGeneration = 0;
        offWindGeneration = 0;
        solarGeneration = 0;
        hydroGeneration = 0;
        waveGeneration = 0;
        tidalGeneration = 0;
        nuclearGeneration = 0;
        backupGeneration = 0;
        backupCapUsed = 0;
        
        demandGWh = 0;
        totalGenerationTWh = 0;
        unmetDemand = 0;
        max_shortfall = 0;
        store_total_loss = 0;
    
        energyDemand = [];
        windPower = [];
        solarPower = [];
        CHPPower = [];
        hourlyHeatDemand = [];
        hourlyElecForHeatDemand = [];
        hourlySpaceHeatDemand = [];
        hourlyWaterHeatDemand = [];
        hourlyElecForAppliances = [];
        hourlyElecForTransport = [];
        hourlyElecForIndustry = [];
        temperatureData = [];
        totalGeneration = [];
        totalGenerationWithStorage = [];
        backupUsed = [];
        unmet = [];

        $("[key]").each(function(){
            var keyparts = $(this).attr('key').split(".");
            if (keyparts[0]=='input') window[keyparts[1]] = parseFloat($(this).val());
        });

        demandProfile = 0;
        totalDemand = parseFloat($('input[key="input.appliancesDemand_TWh"]').val());
        baseTemp = 16-(385/((heatLossCoefficient/4.398)*119)); //Gains need linking to appliances energy reduction
        totalHeatDemand = 0;
        totalDemandInProfile = 0;
        
        heatPumpCoP = 2.5;
        hotWaterDemand = hotWaterDemand_TWh*1000/8760;
        transportDemand = transportDemand_TWh*1000/8760;
        industryDemand = industryDemand_TWh*1000/8760;

        store_max_capacity = store_max_capacity_GWh;
        store_start_capacity = store_start_capacity_GWh;
        //------------------------------------------------
        // Variables to record utilisation of store
        store_used_discharge_rate = 0;
        store_used_charge_rate = 0;
        store_used_min_capacity = store_max_capacity;
        store_used_max_capacity = 0;
        store_total_charge = 0;
        store_total_discharge = 0;
        store_total_loss = 0;
        //------------------------------------------------
        store_hourly_capacity = [];
        storageChange = [];
        storageSupply = [];
        store_capacity = store_start_capacity;
               
        x=0;
        var lines = csvfile.split(/\r\n|\n/);
        
        for (var i=0; i<lines.length-1; i++) {
            var splitarray = lines[i].split(',');
            
            energyDemand[x] = parseFloat(splitarray[0]);
            
            onWindPower[x] = parseFloat(splitarray[1]) * onWindCap * 0.9;
            offWindPower[x] = parseFloat(splitarray[2]) * offWindCap * 0.9;
            wavePower[x] = parseFloat(splitarray[3]) * waveCap;
            tidalPower[x] = parseFloat(splitarray[4]) * tidalCap;
            solarPower[x] = parseFloat(splitarray[5]) * solarCap;
            
            temperatureData[x] = parseFloat(splitarray[6]);
            
            onWindGeneration += onWindPower[x];
            offWindGeneration += offWindPower[x];
            solarGeneration += solarPower[x];
            hydroGeneration += hydroCap*0.3;
            waveGeneration += wavePower[x];
            tidalGeneration += tidalPower[x];
            nuclearGeneration += nuclearCap*0.9;
            
            if((baseTemp - temperatureData[x]) > 0){
                hourlySpaceHeatDemand[x] = ((baseTemp - temperatureData[x]) * heatLossCoefficient);
            }
            else{
                hourlySpaceHeatDemand[x] = 0;
            }
            
            x++;
        }     
        
        totalDemandInProfile = 0;
        totalHeatDemand = 0;
        solidDemand = 0;
        gasDemand = 0;
        liquidDemand = 0;
        
        x=0;
        for(var i=0; i<8760; i++)
        {
            totalDemandInProfile += energyDemand[i];

            hourlyWaterHeatDemand[i] = hotWaterDemand * 24 * (hotWaterDailyProfile[x]/100);
            hourlySpaceHeatDemand[i] = hourlySpaceHeatDemand[i] * 24 * (spaceHeatingDailyProfile[x]/100);
            hourlyElecForIndustry[i] = industryDemand * 24 * (industrialDailyProfile[x]/100);
                  
            hourlyHeatDemand[i] = hourlySpaceHeatDemand[i] + hourlyWaterHeatDemand[i];
            totalHeatDemand += hourlyHeatDemand[i];
            hourlyElecForHeatDemand[i] = (hourlyHeatDemand[i] * percentHeatHeatpumps / 100 / heatPumpCoP) + (hourlyHeatDemand[i] * percentHeatDirectelec / 100);
            
            // Calculate demand for solid, gas & liquid fuel for heat
            solidDemand += (hourlyHeatDemand[i]*(percentHeatSolid/100))/0.9;
            gasDemand += (hourlyHeatDemand[i]*(percentHeatGas/100))/0.9;
            liquidDemand += (hourlyHeatDemand[i]*(percentHeatLiquid/100))/0.9;
              
            solidDemand += (hourlyHeatDemand[i]*(percentHeatCHPSolid/100))/0.6;
            gasDemand += (hourlyHeatDemand[i]*(percentHeatCHPGas/100))/0.6;
            liquidDemand += (hourlyHeatDemand[i]*(percentHeatCHPLiquid/100))/0.6;
            
            // CHP assumes efficiency of 30% for electricity, 60% for heat
            CHPPower[i] = (hourlyHeatDemand[i]*(percentHeatCHPSolid/100))*(0.3/0.6) + 
                      (hourlyHeatDemand[i]*(percentHeatCHPGas/100))*(0.3/0.6) + 
                      (hourlyHeatDemand[i]*(percentHeatCHPLiquid/100))*(0.3/0.6) + 
                      ((industryCHPSolidDemand/8760)*1000 * 24 * (industrialDailyProfile[x]/100))*0.3 + 
                      ((industryCHPGasDemand/8760)*1000 * 24 * (industrialDailyProfile[x]/100))*0.3 +
                      ((industryCHPLiquidDemand/8760)*1000 * 24 * (industrialDailyProfile[x]/100))*0.3 ;
            
            x++;
            if(x==23) x=0;
        }
        
        hydrogenProduced = 0;
        
        for(var i=0;i<8760;i++)
        {
            var backupgen = 0;
            // energyDemand and totalGeneration in GW
            hourlyElecForAppliances[i] = energyDemand[i] / (totalDemandInProfile/1000) * appliancesDemand_TWh;
            energyDemand[i] = hourlyElecForAppliances[i] + hourlyElecForHeatDemand[i] + transportDemand + hourlyElecForIndustry[i];
            totalGeneration[i] = onWindPower[i] + offWindPower[i] + solarPower[i] + hydroCap*0.3
                    + wavePower[i] + tidalPower[i] + (nuclearCap*0.9) + CHPPower[i];
           
            demandGWh += energyDemand[i];
            totalGenerationTWh += totalGeneration[i];
            
            // supplied after grid losses
            totalGeneration[i] = (onWindPower[i] + offWindPower[i] + hydroCap*0.3
                    + wavePower[i] + tidalPower[i] + (nuclearCap*0.9))*(1-grid_loss) + solarPower[i] + CHPPower[i]; 
            
            var store_capacity_remaining = store_max_capacity-store_capacity;

            // STORE DISCHARGE
            //            Loss
            //             ^
            //             |
            // Store -l2------l1-> Output 
            //         
            // - l1 Rate limit
            // - l2 Capacity limit
            
            if (energyDemand[i] >= totalGeneration[i])
            {
                var shortfall = energyDemand[i] - totalGeneration[i];

                //------------------------------------------------------------------------------------------------------------------------------------------------------------------------
                var store_discharge_rate_after_loss = shortfall;
                if (store_discharge_rate_after_loss>store_max_discharge_rate) store_discharge_rate_after_loss = store_max_discharge_rate;   // 1. Discharge rate limit
                var store_discharge_rate_pre_loss = store_discharge_rate_after_loss / store_discharge_efficiency;                           // 2. Calculate discharge rate pre losses
                if (store_discharge_rate_pre_loss>store_capacity) store_discharge_rate_pre_loss = store_capacity;                           // 3. Empty store limit
                store_discharge_rate_after_loss = store_discharge_rate_pre_loss * store_discharge_efficiency;                               // 4. Work backwards to obtain after loss charge rate again
                var store_loss = store_discharge_rate_pre_loss - store_discharge_rate_after_loss;                                           // 5. Calculate energy lost in charging
                store_capacity -= store_discharge_rate_pre_loss;                                                                            // 6. Calculate new store capacity level
                //------------------------------------------------------------------------------------------------------------------------------------------------------------------------
                store_total_discharge += store_discharge_rate_after_loss;
                store_total_loss += store_loss;
                storageChange[i] += store_discharge_rate_pre_loss;
                storageSupply[i] = store_discharge_rate_after_loss;
                if (store_discharge_rate_after_loss > store_used_discharge_rate) store_used_discharge_rate = store_discharge_rate_after_loss;
                
                totalGenerationWithStorage[i] = totalGeneration[i] + store_discharge_rate_after_loss;
                
                // Record unmet demand
                if ((store_discharge_rate_after_loss+totalGeneration[i])<energyDemand[i]) {
                    shortfall = energyDemand[i]-(store_discharge_rate_after_loss+totalGeneration[i]);   // shortfall pre backup generation
                    backupgen = shortfall;                                                              // assign backup generation
                    if (backupgen>backupCap*(1-grid_loss)) backupgen = backupCap*(1-grid_loss);                                     // backup generation capacity limit
                    shortfall -= backupgen;                                                             // calculate remaining shortfall
                    unmetDemand += shortfall;                                                           // record unmet demand
                    if (shortfall>max_shortfall) max_shortfall = shortfall;                             // record max shortfall
                }
                else{shortfall = 0;}
                //energyDemand[i] -= store_discharge_rate_after_loss;
            }
            
            // STORE CHARGING
            //            Loss
            //             ^
            //             |
            // Surplus -l1---l2-> Store 
            //         
            // - l1 Rate limit
            // - l2 Capacity limit
            
            // Supply exceed's demand, excess energy fed into store
            if (totalGeneration[i]>energyDemand[i])
            {
                var surplus_available = totalGeneration[i] - energyDemand[i];
                
                //------------------------------------------------------------------------------------------------------------------------------------------------------------------------
                var store_charge_rate_pre_loss = surplus_available;
                if (store_charge_rate_pre_loss>store_max_charge_rate) store_charge_rate_pre_loss = store_max_charge_rate;           // 1. Charge rate limit
                var store_charge_rate_after_loss = store_charge_rate_pre_loss * store_charge_efficiency;                            // 2. Calculate charge rate after losses
                if (store_charge_rate_after_loss>store_capacity_remaining) store_charge_rate_after_loss = store_capacity_remaining; // 3. Capacity limit
                store_charge_rate_pre_loss = store_charge_rate_after_loss / store_charge_efficiency;                                // 4. Work backwards to obtain pre loss charge rate again
                var store_loss = store_charge_rate_pre_loss - store_charge_rate_after_loss;                                         // 5. Calculate energy lost in charging
                store_capacity += store_charge_rate_after_loss;                                                                     // 6. Calculate new store capacity level
                //------------------------------------------------------------------------------------------------------------------------------------------------------------------------
                store_total_charge += store_charge_rate_pre_loss;
                store_total_loss += store_loss;
                storageChange[i] = -store_charge_rate_pre_loss;
                storageSupply[i] = 0;
                if (store_charge_rate_pre_loss > store_used_charge_rate) store_used_charge_rate = store_charge_rate_pre_loss;
                
                // adjust energy demand 
                energyDemand[i]+= store_charge_rate_pre_loss;
                // Calculate electrolysis demand
                if((totalGeneration[i] - energyDemand[i]) > electrolysisCap){
                         electrolysisDemand[i] = electrolysisCap;
                }
                else{electrolysisDemand[i] = (totalGeneration[i] - energyDemand[i]);}
                
                energyDemand[i] += electrolysisDemand[i];
                hydrogenProduced += electrolysisDemand[i]*0.7;    
                
                totalGenerationWithStorage[i] = totalGeneration[i];
                
                // record excess generation 
                if (totalGeneration[i]>energyDemand[i]) excessGeneration += totalGeneration[i] - energyDemand[i]; 
                
                shortfall = 0;
            }
            else{electrolysisDemand[i] = 0;}
            
            
            if (store_capacity > store_used_max_capacity) store_used_max_capacity = store_capacity;
            if (store_capacity < store_used_min_capacity) store_used_min_capacity = store_capacity;
            
            store_hourly_capacity[i] = store_capacity;
            
            backupUsed[i] = backupgen/(1-grid_loss); // Backup capacity used
            backupGeneration += backupgen/(1-grid_loss);
            if (backupgen/(1-grid_loss)>backupCapUsed) backupCapUsed = backupgen/(1-grid_loss); //Max backup capacity used
            
            unmet[i] = shortfall;
                     
        }
        
        solidDemand += (appliancesSolidDemand + transportSolidDemand + industrySolidDemand + industryCHPSolidDemand)*1000;
        gasDemand += (appliancesGasDemand + transportGasDemand + industryGasDemand + industryCHPGasDemand)*1000 + (backupGeneration/0.5);
        liquidDemand += (appliancesLiquidDemand + transportLiquidDemand + industryLiquidDemand + industryCHPLiquidDemand)*1000;
        
        //***************************************************************************************************
        // Algorithm to work out biofuels made, fossil fuels still required and residual emissions
        // Biomass to biogas efficiency 0.6, biomass to liquid biofuel efficiency 0.5 
        // Synth fuels assumption: SABATIER: 1 Biomass + 0.5 H2 --> 1 Biomethane. FISCHER-TROPSCH: 1 Biomass + 0.5 H2 --> 0.8 Synthetic liquid fuel.

        var biomass = biomassSupply*1000;               // available biomass
        var hydrogen = hydrogenProduced;                // available hydrogen

        var transport_hydrogen_demand = transportHydrogenDemand*1000;               
        var industry_hydrogen_demand = industryHydrogenDemand*1000;

        var solid_demand = solidDemand;
        var gas_demand = gasDemand;
        var liquid_demand = liquidDemand;
        var solidBiomass = 0;
        
        if(biomass>solid_demand){solidBiomass = solid_demand;}
        else{solidBiomass = biomass;}
        solid_demand -= solidBiomass;

        biomass -= solidBiomass;                        // Biomass solid demand here is prioritiezed over gas and liquid
        hydrogen -= transport_hydrogen_demand;          // H2 to transport
        hydrogen -= industry_hydrogen_demand;           // H2 to industry are also both prioritiezed over gas and liquid
        if(hydrogen<0){hydrogen = 0;}

        //-------------------------------------------------------------------------------------------
        // SUPPLY AS MUCH OF GAS AND LIQUID DEMAND FROM SABATIER & FISCHER-TROPSCH PROCESSES
        //-------------------------------------------------------------------------------------------

        // 1. start by calculating actual requirements of H2 and biomass if full demand was supplied
        // 2. then limit by the actual hydrogen available
        // 3. re-calcuate resultant biomass use
        // 4. then limit by biomass available
        // 5. re-calculate resultant H2 use
        // 6. calculate actual synthetic fuels produced

        // 1. Start by calculating actual requirements of H2 and biomass if full demand was supplied

        // var biomass_for_FT = (1.0/0.8) * liquid_demand;
        var H2_for_FT = (0.5/0.8) * liquid_demand;
        // var biomass_for_sabatier = (1.0) * gas_demand;
        var H2_for_sabatier = (0.5) * gas_demand;
        // var biomass_requirement = biomass_for_FT + biomass_for_sabatier;
        var H2_requirement = H2_for_FT + H2_for_sabatier;
        
        console.log("full H2_requirement: "+H2_requirement);

        // 2. Limit by the actual amount of hydrogen available
        var H2 = hydrogen;                                                      // max H2 available 
        if (H2>H2_requirement) H2 = H2_requirement;                             // limit to demand if demand is larger than supply

        if(useH2ForSynthFuels==0){
            H2_for_FT = (H2_for_FT / H2_requirement) * H2;                          // calculate resulting proportion of available hydrogen available for FT
            H2_for_sabatier = (H2_for_sabatier/H2_requirement) * H2;                // and for sabatier process
        }
        else{
            H2_for_FT = 0;
            H2_for_sabatier = 0;
        }
        // 3. Calcuate resultant biomass use
        var biomass_for_FT = H2_for_FT / 0.5;
        var biomass_for_sabatier = H2_for_sabatier / 0.5;
        var biomass_requirement = biomass_for_FT + biomass_for_sabatier;

        // 4. then limit by biomass available if biomass requirement for hydrogen available is more than biomass available
        if (biomass_requirement > biomass)
        {
            biomass_for_FT = (biomass_for_FT/biomass_requirement) * biomass;
            biomass_for_sabatier = (biomass_for_sabatier/biomass_requirement) * biomass;
            
            // 5. re-calculate hydrogen requirement after biomass limit
            H2_for_FT = biomass_for_FT * 0.5;
            H2_for_sabatier = biomass_for_sabatier * 0.5;
        }

        var biomass_used = biomass_for_FT + biomass_for_sabatier;
        H2_requirement = H2_for_FT + H2_for_sabatier;                    

        biomass -= biomass_used;
        hydrogen -= H2_requirement;

        // 6. calculate actual synthetic fuels produced
        var synthfuel = 0.8*biomass_for_FT;         // == 0.8*0.5*H2_for_FT;
        var biomethane = biomass_for_sabatier;

        // subtract available biomethane and synthfuel from demands
        gas_demand -= biomethane;
        liquid_demand -= synthfuel;

        //-------------------------------------------------------------------------------------------
        // SUPPLY REMAINING DEMAND BY LESS EFFICIENT DIRECT BIOMASS PROCESS
        //-------------------------------------------------------------------------------------------
        
        //biomass_requirement += (gas_demand/0.6 + liquid_demand/0.5); 
        // Start by dividing remaining biomass by gas/liquid demand ratio:
        var max_biomass_for_gas = 0;
        if (gas_demand>0) max_biomass_for_gas = (gas_demand/0.6)/((gas_demand/0.6)+(liquid_demand/0.5)) * biomass;            // biogas
        
        var max_biomass_for_liquid = 0;
        if (liquid_demand>0) max_biomass_for_liquid = (liquid_demand/0.5)/((gas_demand/0.6)+(liquid_demand/0.5)) * biomass;   // biofuel

        var biogas = max_biomass_for_gas * 0.6;                         // calc max biogas production
        if (biogas>gas_demand) biogas = gas_demand;                       // Limit by gas demand
        biomass -= biogas / 0.6;                                        // calc actual biomass used

        var biofuel = max_biomass_for_liquid * 0.5;                     // calc max biofuel production
        if (biofuel>liquid_demand) biofuel = liquid_demand;                  // Limit by liquid demand
        biomass -= biofuel / 0.5;                                       // calc actual biomass used

        gas_demand -= biogas;
        liquid_demand -= biofuel;
      
        //-------------------------------------------------------------------------------------------
        solidBiofuel = solidBiomass;
        gasBiofuel = biomethane+biogas;
        liquidBiofuel = synthfuel+biofuel;
        
        unmet_solid_demand = solid_demand;
        unmet_gas_demand = gas_demand;
        unmet_liquid_demand = liquid_demand;
        
        unmet_hydrogen = 0;
        if(hydrogenProduced<(transportHydrogenDemand + industryHydrogenDemand)*1000){
            unmet_hydrogen = transportHydrogenDemand + industryHydrogenDemand - hydrogenProduced/1000;
        }
        else{unmet_hydrogen = 0;}
        
        residual_emissions = unmet_solid_demand*0.4 + unmet_gas_demand*0.2 + unmet_liquid_demand*0.3 + 1000*unmet_hydrogen*0.2;
        
        hydrogen_surplus = hydrogen;
        if(hydrogen_surplus<0){hydrogen_surplus=0;}
        biomass_surplus = biomass; 
        //-------------------------------------------------------------------------------------------
        
        $("[key]").each(function(){
            var keyparts = $(this).attr('key').split(".");
            var dp = $(this).attr('dp');
            if (dp==undefined) dp = 5;
            var scale = $(this).attr('scale');
            if (scale==undefined) scale = 1;
            if (keyparts[0]=='out') $(this).html((window[keyparts[1]]*scale).toFixed(dp));
        });
        
        draw_graph();
    }

    $(document).ready(function() {
        $.ajax({
            type: "GET",
            url: "textfile.csv",
            dataType: "text",
            success: function(data) {csvfile = data; process();}
         });
    });
    
    $("#run").click(function(){
        process();
    });
    
    $("#balance").click(function(){
        graph_mode = 'balance';
        draw_graph();
    });

    $("#supply").click(function(){
        graph_mode = 'supply';
        draw_graph();
    });
    
    $("#demand").click(function(){
        graph_mode = 'demand';
        draw_graph();
    });
    
    $("#store").click(function(){
        graph_mode = 'store';
        draw_graph();
    });
    
    function draw_graph()
    {
        var c = document.getElementById("graph");  
        var ctx = c.getContext("2d");
        var hr = 0; var day = 0; var week = 1;
        
        ctx.clearRect(0,0,8760,250);
        
        ctx.beginPath();
        ctx.strokeStyle = "#000";
        ctx.moveTo(25,25); ctx.lineTo(25, 225);
        ctx.moveTo(25,226); ctx.lineTo(8785, 226);
        ctx.fillText("Week",25,240);
        ctx.stroke();
        for(var p=1;p<8760;p++){
            if (day == 7){
                ctx.strokeRect(p+25,226,1, 2);
                ctx.fillText(week,p+25,240);
                day = 0;
                week++;
            }
            if(hr == 24) {day++; hr = 0;}
            hr++;
        }
        
        // Draw balance graph
        if(graph_mode == 'balance'){
            
            var level_colors = ["#00ff00","#ff0000"];
            var level_labels = ["Surplus of electricity","Shortfall of electricity"];
            
            ctx.strokeRect(23,25,1, 2);
            ctx.strokeRect(23,125,1, 2);
            ctx.fillText("GW",2,10);
            ctx.fillText("200",2,28);
            ctx.fillText("100",2,128);
            
            for (var i=0; i<2; i++)
            {
                ctx.fillStyle = level_colors[i];
                ctx.fillRect(40,i*15,10,10);
                ctx.strokeStyle = "#000";
                ctx.fillStyle = "#000";
                ctx.strokeRect(40,i*15,10,10);
                ctx.fillText(level_labels[i],60,10+i*15);
            }
            
            for(var p=1;p<8760;p++){
            
                ctx.beginPath();
                ctx.strokeStyle = "#0000ff";
                windSquarePos = Math.round(totalGenerationWithStorage[p-1]);
                windSquarePos1 = Math.round(totalGenerationWithStorage[p]);
                ctx.moveTo(p+26, 25+(200-windSquarePos1));
                ctx.lineTo(p+25, 25+(200-windSquarePos));
                ctx.stroke();
                
                ctx.beginPath();
                ctx.strokeStyle = "#000";
                demandSquarePos = Math.round(energyDemand[p-1]);
                demandSquarePos1 = Math.round(energyDemand[p]);
                ctx.moveTo(p+26, 25+(200-demandSquarePos1));
                ctx.lineTo(p+25, 25+(200-demandSquarePos));
                ctx.stroke();
                
                if(windSquarePos>demandSquarePos){
                    ctx.beginPath();
                    ctx.strokeStyle = "#00ff00";
                    ctx.moveTo(p+26, 25+(200-windSquarePos+1));
                    ctx.lineTo(p+25, 25+(200-demandSquarePos-1));
                    ctx.stroke();
                }
                else if(windSquarePos<demandSquarePos){
                
                    ctx.beginPath();
                    ctx.strokeStyle = "#ff0000";
                    ctx.moveTo(p+26, 25+(200-windSquarePos-1));
                    ctx.lineTo(p+25, 25+(200-demandSquarePos+1));
                    ctx.stroke();
                }
            }
        }
        
        //Draw demand graph
        else if(graph_mode == 'demand'){
            
            var ymax = 200;
            var level_colors = ["#0000cc","#FF0000","#cc9900","#de2bf3","#66FF00","#FFFF00"];
            var level_labels = ["Appliances","Heat","Transport","Industry","Electric store charge", "Electrolysis"];
            
            ctx.strokeRect(23,25,1, 2);
            ctx.strokeRect(23,125,1, 2);
            ctx.fillText("GW",2,10);
            ctx.fillText("200",2,28);
            ctx.fillText("100",2,128);
            
            for (var i=0; i<3; i++)
            {
                ctx.fillStyle = level_colors[i];
                ctx.fillRect(40,i*15,10,10);
                ctx.strokeStyle = "#000";
                ctx.fillStyle = "#000";
                ctx.strokeRect(40,i*15,10,10);
                ctx.fillText(level_labels[i],60,10+i*15);
            }            
            for (var i=3; i<level_labels.length; i++)
            {
                ctx.fillStyle = level_colors[i];
                ctx.fillRect(120,(i-3)*15,10,10);
                ctx.strokeStyle = "#000";
                ctx.fillStyle = "#000";
                ctx.strokeRect(120,(i-3)*15,10,10);
                ctx.fillText(level_labels[i],140,10+(i-3)*15);
            }
            
            for(var p=1;p<8760;p++){
                var elecstore_charge = 0;
                if (storageChange[p-1]<0) elecstore_charge = -1*storageChange[p-1];
                
                var l = [];                
                l[0] = hourlyElecForAppliances[p-1];
                l[1] = l[0] + hourlyElecForHeatDemand[p-1];
                l[2] = l[1] + transportDemand;
                l[3] = l[2] + hourlyElecForIndustry[p-1];
                l[4] = l[3] + elecstore_charge;
                l[5] = l[4] + electrolysisDemand[p-1];
                
                // fill
                for (var i=0; i<l.length; i++)
                {
                    var posA = 0;
                    if (i>0) posA = (l[i-1]/ymax)*200;
                    var posB = (l[i]/ymax)*200;
                    ctx.strokeStyle = level_colors[i];
                    ctx.beginPath();
                    ctx.moveTo(p+25, 25+(200-posA));
                    ctx.lineTo(p+25, 25+(200-posB));
                    ctx.stroke();
                }
            }
            /*for(var p=1;p<8760;p++){
            
                ctx.strokeStyle = "#0000cc";
                demandSquarePos = Math.round(energyDemand[p-1]);
                ctx.beginPath();
                ctx.moveTo(p+25, 25+(200-demandSquarePos));
                ctx.lineTo(p+25, 225);
                ctx.stroke();  // Draw total in blue
                
                ctx.strokeStyle = "#FF0000";
                demandSquarePos = Math.round(hourlyElecForHeatDemand[p-1]);
                ctx.beginPath();
                ctx.moveTo(p+25, 25+(200-demandSquarePos));
                ctx.lineTo(p+25, 225);
                ctx.stroke();  // Draw heat in red
                
                demandSquarePos1 = transportDemand;
                ctx.strokeStyle = "#cc9900";
                ctx.beginPath();
                ctx.moveTo(p+25, 25+(200-demandSquarePos));
                ctx.lineTo(p+25, 25+(200-(demandSquarePos+demandSquarePos1)));
                ctx.stroke();  // Draw tranpsort in orange
                
                ctx.strokeStyle = "#de2bf3";
                demandSquarePos2 = Math.round(hourlyElecForIndustry[p-1]);
                ctx.beginPath();
                ctx.moveTo(p+25, 25+(200-(demandSquarePos+demandSquarePos1)));
                ctx.lineTo(p+25, 25+(200-(demandSquarePos+demandSquarePos1+demandSquarePos2)));
                ctx.stroke();  // Draw industry in purple
                
                demandSquarePos = Math.round(energyDemand[p-1]);
                if(storageChange[p-1]<0){
                    ctx.strokeStyle = "#66FF00";                    
                    ctx.beginPath();
                    ctx.moveTo(p+25, 25+(200-demandSquarePos-Math.round(storageChange[p-1])));
                    ctx.lineTo(p+25, 25+(200-demandSquarePos));
                    ctx.stroke();  
                }
                
                if(electrolysisDemand[p-1]>0){
                    ctx.strokeStyle = "#FFFF00";                    
                    ctx.beginPath();
                    ctx.moveTo(p+25, 25+(200-demandSquarePos-Math.round(storageChange[p-1]-Math.round(electrolysisDemand[p-1]))));
                    ctx.lineTo(p+25, 25+(200-demandSquarePos-Math.round(storageChange[p-1])));
                    ctx.stroke();  
                }/*
                if(storageChange[p-1]>0){
                    ctx.strokeStyle = "#f477e4";
                    ctx.beginPath();
                    ctx.moveTo(p+25, 25+(200-demandSquarePos+Math.round(storageChange[p-1])));
                    ctx.lineTo(p+25, 25+(200-demandSquarePos));
                    ctx.stroke();
                }
            }*/
        }
        //Draw supply graph 
        else if(graph_mode == 'supply'){
            
            var level_colors = ["#ff9900","#990099","#663300","#336666"];
            var level_labels = ["CHP","Nuclear","Hydro","Wave"];
            
            ctx.strokeRect(23,25,1, 2);
            ctx.strokeRect(23,125,1, 2);
            ctx.fillText("GW",2,10);
            ctx.fillText("200",2,28);
            ctx.fillText("100",2,128);
            
            for (var i=0; i<level_labels.length; i++)
            {
                ctx.fillStyle = level_colors[i];
                ctx.fillRect(40,i*15,10,10);
                ctx.strokeStyle = "#000";
                ctx.fillStyle = "#000";
                ctx.strokeRect(40,i*15,10,10);
                ctx.fillText(level_labels[i],60,10+i*15);
            }            
            level_colors = ["#33CC66","#f9e117","#0000FF","#00CCFF"];
            level_labels = ["Tidal","Solar","Offshore wind","Onshore wind"];
            
            for (var i=0; i<level_labels.length; i++)
            {
                ctx.fillStyle = level_colors[i];
                ctx.fillRect(100,i*15,10,10);
                ctx.strokeStyle = "#000";
                ctx.fillStyle = "#000";
                ctx.strokeRect(100,i*15,10,10);
                ctx.fillText(level_labels[i],120,10+i*15);
            }
            level_colors = ["#33ff00","#ff0000","#a9a9a9"];
            level_labels = ["Electric store","Back-up","Unmet"];
            
            for (var i=0; i<level_labels.length; i++)
            {
                ctx.fillStyle = level_colors[i];
                ctx.fillRect(200,i*15,10,10);
                ctx.strokeStyle = "#000";
                ctx.fillStyle = "#000";
                ctx.strokeRect(200,i*15,10,10);
                ctx.fillText(level_labels[i],220,10+i*15);
            }
            
            for(var p=1;p<8760;p++){ 
                
                ctx.strokeStyle = "#00ff00";
                onWindSquarePos = Math.round(onWindPower[p-1]*(1-grid_loss));
                offWindSquarePos = Math.round(offWindPower[p-1]*(1-grid_loss));
                solarPos = Math.round(solarPower[p-1]);
                wavePos = Math.round(wavePower[p-1]*(1-grid_loss));
                tidalPos = Math.round(tidalPower[p-1]*(1-grid_loss));
                CHPPos = Math.round(CHPPower[p-1]);
                hydroPos = Math.round((hydroCap * 0.3)*(1-grid_loss));
                nuclearPos = Math.round((nuclearCap * 0.9)*(1-grid_loss));
                storePos = Math.round(storageSupply[p-1]);
                backupPos = Math.round(backupUsed[p-1]*(1-grid_loss));
                unmetPos = Math.round(unmet[p-1]);
                
                ctx.strokeStyle = "#ff9900";  //orange
                ctx.beginPath();
                ctx.moveTo(p+25, 25+(200-CHPPos));
                ctx.lineTo(p+25, 225);
                ctx.stroke();
                
                ctx.strokeStyle = "#990099"; //purple                  
                ctx.beginPath();
                ctx.moveTo(p+25, 25+(200-CHPPos-nuclearPos));
                ctx.lineTo(p+25, 25+(200-CHPPos));
                ctx.stroke();
                
                ctx.strokeStyle = "#663300"; // Brown                   
                ctx.beginPath();
                ctx.moveTo(p+25, 25+(200-CHPPos-nuclearPos-hydroPos));
                ctx.lineTo(p+25, 25+(200-CHPPos-nuclearPos));
                ctx.stroke();
                
                ctx.strokeStyle = "#336666"; //Aqua blue                  
                ctx.beginPath();
                ctx.moveTo(p+25, 25+(200-CHPPos-nuclearPos-hydroPos-wavePos));
                ctx.lineTo(p+25, 25+(200-CHPPos-nuclearPos-hydroPos));
                ctx.stroke();
                
                ctx.strokeStyle = "#33CC66"; //Greeny blue                    
                ctx.beginPath();
                ctx.moveTo(p+25, 25+(200-CHPPos-nuclearPos-hydroPos-wavePos-tidalPos));
                ctx.lineTo(p+25, 25+(200-CHPPos-nuclearPos-hydroPos-wavePos));
                ctx.stroke();
                               
                ctx.strokeStyle = "#f9e117";  //Yellow                  
                ctx.beginPath();
                ctx.moveTo(p+25, 25+(200-nuclearPos)-CHPPos-hydroPos-wavePos-tidalPos-solarPos);
                ctx.lineTo(p+25, 25+(200-nuclearPos)-CHPPos-hydroPos-wavePos-tidalPos);
                ctx.stroke();
                
                ctx.strokeStyle = "#0000FF"; //blue
                ctx.beginPath();
                ctx.moveTo(p+25, 25+(200-nuclearPos)-CHPPos-hydroPos-wavePos-tidalPos-solarPos-offWindSquarePos);
                ctx.lineTo(p+25, 25+(200-nuclearPos)-CHPPos-hydroPos-wavePos-tidalPos-solarPos);
                ctx.stroke();
                
                ctx.strokeStyle = "#00CCFF"; //light blue
                ctx.beginPath();
                ctx.moveTo(p+25, 25+(200-nuclearPos)-CHPPos-hydroPos-wavePos-tidalPos-solarPos-offWindSquarePos-onWindSquarePos);
                ctx.lineTo(p+25, 25+(200-nuclearPos)-CHPPos-hydroPos-wavePos-tidalPos-solarPos-offWindSquarePos);
                ctx.stroke();
                
                ctx.strokeStyle = "#33ff00"; //Green
                ctx.beginPath();
                ctx.moveTo(p+25, 25+(200-nuclearPos)-CHPPos-hydroPos-wavePos-tidalPos-solarPos-offWindSquarePos-onWindSquarePos-storePos);
                ctx.lineTo(p+25, 25+(200-nuclearPos)-CHPPos-hydroPos-wavePos-tidalPos-solarPos-offWindSquarePos-onWindSquarePos);
                ctx.stroke();
                
                ctx.strokeStyle = "#ff0000"; // Red
                ctx.beginPath();
                ctx.moveTo(p+25, 25+(200-nuclearPos)-CHPPos-hydroPos-wavePos-tidalPos-solarPos-offWindSquarePos-onWindSquarePos-storePos-backupPos);
                ctx.lineTo(p+25, 25+(200-nuclearPos)-CHPPos-hydroPos-wavePos-tidalPos-solarPos-offWindSquarePos-onWindSquarePos-storePos);
                ctx.stroke();
                
                ctx.strokeStyle = "#a9a9a9"; // grey
                ctx.beginPath();
                ctx.moveTo(p+25, 25+(200-nuclearPos)-CHPPos-hydroPos-wavePos-tidalPos-solarPos-offWindSquarePos-onWindSquarePos-storePos-backupPos-unmetPos);
                ctx.lineTo(p+25, 25+(200-nuclearPos)-CHPPos-hydroPos-wavePos-tidalPos-solarPos-offWindSquarePos-onWindSquarePos-storePos-backupPos);
                ctx.stroke();
                              
            }
        }//Draw store graph 
        else if(graph_mode == 'store'){
            
            ctx.strokeRect(23,25,1, 2);
            ctx.strokeRect(23,125,1, 2);
            ctx.fillText("%",2,10);
            ctx.fillText("100",2,28);
            ctx.fillText("50",2,128);
            
            for(var p=1;p<8760;p++){
                
                cap = Math.round(store_hourly_capacity[p-1]*(200/store_max_capacity));
                
                ctx.strokeStyle = "#ffcc00"; // orange
                ctx.beginPath();
                ctx.moveTo(p+25, 25+(200-cap));
                ctx.lineTo(p+25, 225);
                ctx.stroke();
                
                ctx.strokeStyle = "#000"; // orange
                ctx.beginPath();
                ctx.moveTo(p+25, 24+(200-cap));
                ctx.lineTo(p+25, 26+(200-cap));
                ctx.stroke();
            }        
        }
    }

</script>


